<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  <subtitle>web前端</subtitle>
  <link href="https://jjeejj.github.io/atom.xml" rel="self"/>
  
  <link href="https://jjeejj.github.io/"/>
  <updated>2021-06-08T10:43:22.145Z</updated>
  <id>https://jjeejj.github.io/</id>
  
  <author>
    <name>jjeejj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为hexo博客添加service worker的功能</title>
    <link href="https://jjeejj.github.io/2018/09/23/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0serviceworker%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>https://jjeejj.github.io/2018/09/23/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0serviceworker%E7%9A%84%E5%8A%9F%E8%83%BD/</id>
    <published>2018-09-23T10:40:48.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>为 <code>hexo</code> 博客添加 <code>Service worker</code> 功能,方便离线访问</p><hr><span id="more"></span><p>首先先说明一下,对于用在 <code>hexo</code> 上的<code>Service worker</code> 插件,现在<code>github</code> 上一共有两个插件:</p><ol><li><a href="https://github.com/JLHwung/hexo-offline">hexo-offline</a></li><li><a href="https://github.com/zoumiaojiang/hexo-service-worker">hexo-service-worker</a></li></ol><p>对于这两个插件的异同,分别是:</p><p><strong>相同点</strong></p><ul><li>都是使用 <a href="https://github.com/GoogleChromeLabs/sw-precache">sw-precache</a> 这个模块为基础</li><li>由于 <code>hexo-service-worker</code> 是参考 <code>hexo-offline</code> 所以配置语法是一致的</li></ul><p><strong>不同点</strong></p><ul><li><code>hexo-service-worker</code> 对每个 html 页面都会单独有注册 <code>service worker</code> 的入口，这样当用户访问任何页面的时候都能够进行缓存</li><li><code>hexo-service-worker</code> 在检测更新机制方面做了一些工作，当你的 <code>hexo</code> 站点有更新，有一种机制可以马上通知到用户端</li></ul><hr><p>所以下面,就用 <code>hexo-service-worker</code> 来为 <code>hexo</code> 添加<code>Service worker</code> 功能</p><p><strong>安装</strong></p><p><code>npm i hexo-service-worker --save</code></p><p>然后激活插件 : <code>hexo clean &amp;&amp; hexo g</code></p><p><strong>配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service_worker:</span></span><br><span class="line">  <span class="attr">maximumFileSizeToCacheInBytes:</span> <span class="number">5242880</span></span><br><span class="line">  <span class="attr">staticFileGlobs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">public/**/*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125;</span></span><br><span class="line">  <span class="attr">stripPrefix:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">verbose:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>但是这样会有一个问题: 菜单图表会不显示了,所有本网站的博客,没有使用<code>Service worker</code> 功能,只是看看怎么配置的 </p></blockquote><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;为 &lt;code&gt;hexo&lt;/code&gt; 博客添加 &lt;code&gt;Service worker&lt;/code&gt; 功能,方便离线访问&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://jjeejj.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Tampermonkey的使用</title>
    <link href="https://jjeejj.github.io/2018/04/10/Tampermonkey%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://jjeejj.github.io/2018/04/10/Tampermonkey%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-04-10T23:41:48.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>今天就介绍一款浏览器插件的使用:<code>Tampermonkey</code>,又称为<strong>油猴</strong>, 是一款流行的<strong>用户脚本管理器</strong></p><p>基本可是适用与各种浏览器:<code>Chrome,Edge,Saair,Opera,Firefox</code></p><hr><span id="more"></span><p><code>Tampermonkey</code> 将在你的用户脚本管理方面提供更多的便利.它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能，同时<code>Tampermonkey</code>还有可能正常运行原本并不兼容的脚本</p><p>你可以在谷歌的应用商店搜索<code>tampermonkey</code>进行安装,也可以用过<code>tampermonkey</code>的<a href="http://tampermonkey.net/">官网</a>进行安装</p><p>安装成功之后,会弹出来一个文档介绍的网页,可以进行阅读了解其中的功能</p><p>之后我们可以点击扩展图标,在点击获取新脚本,会弹出一个脚本网站列表,网站中有上万个<strong>脚本</strong>,你可以选择你需要的脚本文件</p><p>我们选择一个网站 <a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a> 进去之后选择我们需要的脚本进行安装,比如选择<code>VIP视频在线解析</code>,安装之后就可以使用<br><img src="/images/Tampermonkey%E7%9A%84%E4%BD%BF%E7%94%A8/vip.jpg" alt="vip"></p><p>可以点击扩展图标,进入<code>管理面板</code>关联所有已经安装的用户脚本,这些脚本的源代码都是可见的,可修改的<br><img src="/images/Tampermonkey%E7%9A%84%E4%BD%BF%E7%94%A8/manage_panel.jpg" alt="manage_pancel"></p><p>如果没有找到你需要的用户脚本,你可以点击管理面板中的<strong>➕</strong>自己用<code>JavaScript</code>写一个脚本文件</p><p><em><strong>如果你有好用的油猴-用户脚本,可以推荐出来,大家一起来使用</strong></em></p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;今天就介绍一款浏览器插件的使用:&lt;code&gt;Tampermonkey&lt;/code&gt;,又称为&lt;strong&gt;油猴&lt;/strong&gt;, 是一款流行的&lt;strong&gt;用户脚本管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本可是适用与各种浏览器:&lt;code&gt;Chrome,Edge,Saair,Opera,Firefox&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="other" scheme="https://jjeejj.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>atom配置ftp服务</title>
    <link href="https://jjeejj.github.io/2018/03/25/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/"/>
    <id>https://jjeejj.github.io/2018/03/25/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/</id>
    <published>2018-03-25T12:02:53.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>通常我们本地写代码是需要上传到测试服务器上进行测试,但是每次都登录服务器,通过<code>scp</code>命令进行文件传输,比较麻烦</p><p>下面就在开发工具<code>atom</code>配置<code>ftp</code>服务使<code>项目文件与服务器文件直接对应上</code>,达到文件夹共享的功能</p><hr><span id="more"></span><h5 id="安装ftp功能的插件"><a href="#安装ftp功能的插件" class="headerlink" title="安装ftp功能的插件"></a>安装ftp功能的插件</h5><p>在<code>atom</code>上安装插件的地方搜索<code>remote-ftp</code>,并安装</p><p><img src="/images/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/ftp_install.jpg" alt="alt"></p><h5 id="配置ftp服务"><a href="#配置ftp服务" class="headerlink" title="配置ftp服务"></a>配置ftp服务</h5><ol><li><p>打开一个需要共享的项目文件夹或者新建一个文件夹</p></li><li><p>打开<code>ftp</code>配置的侧边栏可以通过<code>Packages -&gt; Remote FTP -&gt; Toggle</code>或者快捷键打开<code>control+option+o</code><br><img src="/images/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/ftp_sidebar.jpg" alt="alt"></p></li><li><p>新建一个<code>sfpt</code>配置文件通过<code>Packages -&gt; Remote FTP -&gt; Create SFTP config file</code>通过方式创建的配置文件有一些默认的配置想,若直接点击侧边栏的<code>Edit Configuration</code>会创建一个空白的配置文件<br>配置文件的内容为:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;sftp&quot;</span>, <span class="comment"># 协议名称 有sftp 和  ftp</span></span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;example.com&quot;</span>, <span class="comment"># 服务器地址,可以是域名或者ip地址</span></span><br><span class="line">    <span class="string">&quot;port&quot;</span>: 22, <span class="comment"># 服务端口</span></span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="comment"># 服务器用户名</span></span><br><span class="line">    <span class="string">&quot;pass&quot;</span>: <span class="string">&quot;pass&quot;</span>, <span class="comment"># 服务器密码</span></span><br><span class="line">    <span class="string">&quot;promptForPass&quot;</span>: <span class="literal">false</span>, <span class="comment"># 是否弹出输入密码提示</span></span><br><span class="line">    <span class="string">&quot;remote&quot;</span>: <span class="string">&quot;/&quot;</span>, <span class="comment"># 服务器上需要连接的文件夹,绝对地址</span></span><br><span class="line">    <span class="string">&quot;local&quot;</span>: <span class="string">&quot;./&quot;</span>, <span class="comment"># 本地需要共享的文件夹</span></span><br><span class="line">    <span class="string">&quot;agent&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;privatekey&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passphrase&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hosthash&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ignorehost&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;connTimeout&quot;</span>: 10000, <span class="comment"># 多长时间等待连接完成，连接超时</span></span><br><span class="line">    <span class="string">&quot;keepalive&quot;</span>: 10000, <span class="comment"># 多长时间发生 dummy 命令区保持连接</span></span><br><span class="line">    <span class="string">&quot;keyboardInteractive&quot;</span>: <span class="literal">false</span>, <span class="comment"># 是否开启验证码 键盘交互</span></span><br><span class="line">    <span class="string">&quot;keyboardInteractiveForPass&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;remoteCommand&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;remoteShell&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;watch&quot;</span>: [], <span class="comment"># 监听哪些文件或者文件夹,当有改动时就会自动上传</span></span><br><span class="line">    <span class="string">&quot;watchTimeout&quot;</span>: 500 <span class="comment"># 文件最后一次修改到开始上传之间的延迟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里通过<code>SFTP</code>进行讲解,由于<code>FTP</code>服务需要在服务端启动<code>FTP</code>服务</p></blockquote></li><li><p>修改配置完成之后可以在侧边栏进行<strong>连接服务</strong>或者修改配置文件,连接成功之后的显示<br><img src="/images/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/ftp_success.jpg" alt="alt"></p></li><li><p>同步本地的项目文件<br><img src="/images/atom%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1/ftp_sync.jpg" alt="alt"></p></li><li><p>最后如果有文件不需要上到服务器的可以添加<code>.ftpignore</code>文件<code>Packages -&gt; Remote FTP -&gt; Create ignore file</code>用法和<code>.gitignore</code>一样</p></li></ol><p><strong>完成！！！</strong> <em><strong>到此为止本地的文件夹就已经和远程的文件夹关联起来了,若监听对应的文件夹,那么修改后就会自动上传到服务器了</strong></em></p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;通常我们本地写代码是需要上传到测试服务器上进行测试,但是每次都登录服务器,通过&lt;code&gt;scp&lt;/code&gt;命令进行文件传输,比较麻烦&lt;/p&gt;
&lt;p&gt;下面就在开发工具&lt;code&gt;atom&lt;/code&gt;配置&lt;code&gt;ftp&lt;/code&gt;服务使&lt;code&gt;项目文件与服务器文件直接对应上&lt;/code&gt;,达到文件夹共享的功能&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="atom" scheme="https://jjeejj.github.io/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之htpasswd</title>
    <link href="https://jjeejj.github.io/2018/03/22/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bhtpasswd/"/>
    <id>https://jjeejj.github.io/2018/03/22/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bhtpasswd/</id>
    <published>2018-03-22T21:46:56.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>htpasswd</code>是<code>Apache</code>的<code>Web</code>服务器内置的工具,用于创建和更新储存用户名和用户基本认证的密码文件</p><hr><span id="more"></span><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li>由于该工具是<code>Apache</code>的<code>Web</code>服务器内置的工具,所以直接安装<code>Apache</code>,在对应的<code>bin</code>目录下可以看到该命令的</li><li>还可以直接安装<code>httpd-tools</code>这个工具包,比如：<code>yum install httpd-tools</code>,安装成功后就可以直接使用该命令</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>htpasswd (选项) (参数)</code></p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li><code>-c</code>: 创建一个新的密码文件</li><li><code>-b</code>: 在命令行中一并输入用户名和密码而不是根据提示输入密码</li><li><code>-D</code>: 删除指定的用户</li><li><code>-n</code>: 不更新密码文件,只将加密后的用户名密码输出到屏幕上</li><li><code>-p</code>: 不对密码进行加密,采用明文的方式</li><li><code>-m</code>: 采用MD5算法对密码进行加密(<strong>默认的加密方式</strong>)</li><li><code>-d</code>: 采用CRYPT算法对密码进行加密</li><li><code>-s</code>: 采用SHA算法对密码进行加密</li><li><code>-B</code>: 采用bcrypt算法对密码进行加密(<strong>非常安全</strong>)</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>用户名: 要创建或者更新的用户名</li><li>密码: 用户的新密码</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li><p>新建一个密码文件<code>.passwd</code>并添加一个用户,不提示直接输入用户名密码<br> <code>htpasswd -bc .passwd jiang wen</code></p></li><li><p>在原有的密码文件<code>.passwd</code>下在添加一个用户<br> <code>htpasswd -b .passwd wen jiang</code></p></li><li><p>更新用户的密码:有两种方式<br>第一种,直接添加相同的用户名，就会自动区更新密码：<code>htpasswd -b .passwd wen wen</code><br>第二种,先删除需要更新密码的用户名,在添加用户：<code>htpassdw -D .passwd wen &amp; htpasswd -b .passwd wen wen</code></p></li><li><p>不更新密码文件，只显示加密后的用户名和密码<br> <code>htpasswd -bn jiang jiang</code></p></li><li><p><strong>nginx</strong>模块 <a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html">http_auth_basic_module</a>中的使用,用于生成用户密码文件进行认证</p></li></ol><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;htpasswd&lt;/code&gt;是&lt;code&gt;Apache&lt;/code&gt;的&lt;code&gt;Web&lt;/code&gt;服务器内置的工具,用于创建和更新储存用户名和用户基本认证的密码文件&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>有关Promise.catch方法的理解</title>
    <link href="https://jjeejj.github.io/2018/03/04/%E6%9C%89%E5%85%B3Promise-catch%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://jjeejj.github.io/2018/03/04/%E6%9C%89%E5%85%B3Promise-catch%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-03-04T13:50:13.000Z</published>
    <updated>2021-06-08T10:43:22.149Z</updated>
    
    <content type="html"><![CDATA[<hr><p>之前写了一篇有关<code>Promise</code>的<code>then</code><a href="https://mp.weixin.qq.com/s/PnoRPIgr1xYzOqLPNpqK5g">方法的文章</a>,现在在讲解一下有关<code>Promise</code>原型上<code>catch</code>的方法</p><hr><span id="more"></span><p><code>catch</code>方法是为了处理拒绝的情况或者抛出异常的情况</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.catch(onRejected);</span><br><span class="line"></span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><code>onRejected</code>:当<code>Promise</code> 被拒绝时,被调用的一个<code>Function</code>,该函数拥有一个参数</li><li><code>reson</code>: 拒绝的原因</li></ul><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>一个新的<code>Promise</code></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="返回的Promise行为状态"><a href="#返回的Promise行为状态" class="headerlink" title="返回的Promise行为状态"></a>返回的Promise行为状态</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`e`</span>,e); <span class="comment">// &quot;e oh, no!&quot;</span></span><br><span class="line">  <span class="comment">//或者</span></span><br><span class="line">  <span class="comment">//Promise.resolve();</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>,value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line">上面的打印结果为:</span><br><span class="line">Success</span><br><span class="line">e oh, no!</span><br><span class="line">after a <span class="keyword">catch</span> the chain is restored <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`e`</span>,e); <span class="comment">// &quot;e oh, no!&quot;</span></span><br><span class="line">  <span class="comment">//或者</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>,value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line">上面的打印结果为:</span><br><span class="line">Success</span><br><span class="line">e oh, no!</span><br><span class="line">after a <span class="keyword">catch</span> the chain is restored <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>若把上面的代码改为以下这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`e`</span>,e); <span class="comment">// &quot;e oh, no!&quot;</span></span><br><span class="line">  <span class="comment">//或者</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;ssssss&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>,value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line">上面的打印结果为:</span><br><span class="line">Success</span><br><span class="line">e oh, no!</span><br><span class="line">Not fired due to the <span class="keyword">catch</span> ssssss</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`e`</span>,e); <span class="comment">// &quot;e oh, no!&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;ssssss&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>,value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">上面的打印结果为:</span><br><span class="line">Success</span><br><span class="line">e oh, no!</span><br><span class="line">Not fired due to the <span class="keyword">catch</span> ssssss</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看出<code>catch</code>返回的<code>Promise</code>状态和<code>then</code>方法中的行为是一致的,具体请参考<a href="https://mp.weixin.qq.com/s/PnoRPIgr1xYzOqLPNpqK5g">then</a></p><p><strong>抛出一个错误或返回一个失败的 <code>Promise</code>,<code>Promise</code> 通过 catch() 返回失败onRejected状态的结果;否则,它将返回成功的<code>onFulfilld</code>状态的数据</strong></p><h5 id="异常捕获的行为"><a href="#异常捕获的行为" class="headerlink" title="异常捕获的行为"></a>异常捕获的行为</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出一个错误，大多数时候将调用catch方法</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Uh-oh!&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// &quot;Uh-oh!&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步函数中抛出的错误不会被catch捕获到</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;Uncaught Exception!&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在resolve()后面抛出的错误会被忽略</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Silenced Exception!&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(e); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;之前写了一篇有关&lt;code&gt;Promise&lt;/code&gt;的&lt;code&gt;then&lt;/code&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PnoRPIgr1xYzOqLPNpqK5g&quot;&gt;方法的文章&lt;/a&gt;,现在在讲解一下有关&lt;code&gt;Promise&lt;/code&gt;原型上&lt;code&gt;catch&lt;/code&gt;的方法&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="js" scheme="https://jjeejj.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>利用CI自动部署hexo博客</title>
    <link href="https://jjeejj.github.io/2018/02/11/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jjeejj.github.io/2018/02/11/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-02-11T22:41:58.000Z</published>
    <updated>2021-06-08T10:43:22.149Z</updated>
    
    <content type="html"><![CDATA[<hr><p>每次写完一篇文章,都会手动执行<code>hexo g</code>和<code>hexo d</code>去生成静态网页后在进行部署到<code>Github page上去</code> </p><p>而且为了保存文章的源码<code>md</code>文件还需要<code>push</code>到对应的仓库分支上,比较麻烦</p><p>都说<code>懒惰</code>推动着新的东西出现,那么能不能只保存原<code>md</code>文件<code>push</code>上去,其他的操作都让它自动去完成呢 ？</p><p>答案肯定是可以的,下面就来讲解一下CI具体的实现方法(<strong>这里只讲解如何把travis接入</strong>):</p><hr><span id="more"></span><p>首先来介绍利用的工具: </p><ul><li><code>Github Page</code>:是<code>github</code>网站提供的静态网站服务,集体详细的介绍可以查看<a href="https://pages.github.com/">官方文档</a></li><li><code>travis</code>: 是在线托管的<code>CI</code>服务,用<code>Travis</code>来进行持续集成,不需要自己搭服务器<a href="https://travis-ci.org/">官方网站</a></li></ul><p>接入<code>Travis</code>过程:</p><ol><li>登录<code>Travis</code>网站用<code>github</code>授权登录</li><li>登录后在个人主页选择你需要<code>CI</code>的仓库</li><li>点击你选择的<code>hexo</code>博客的仓库进行配置<br>点击左上角红色框的<strong>More options</strong>按钮,选择<code>Settings</code>打开配置页面进行配置<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/ci_setting.jpg" alt="alt"></li></ol><p>第一个配置项:<code>Build only if .travis.yml is present</code>代表的意思是:只有在<code>.travis.yml</code>文件中配置的<strong>分支</strong>改变了才构建<br>第二个配置项:<code>Build pushes</code>代表当推送完这个分支后开始构建</p><p>到了这一步,我们已经开启了要构建的仓库,但是还有个问题就是,构建完后,我们怎么将生成的文件推送到github上呢?<br>我们只要想<code>github一push</code>,他就自动构建并<code>push</code>静态文件到<code>githubpages</code>,那么下面要解决的就是<code>Travis CI</code>怎么访问<code>github</code>了</p><ol start="4"><li>在<code>Travis CI</code>配置<code>Github</code>的<code>Access Token</code> 用来访问<code>Github</code></li></ol><p>首先我们进入<code>github</code>的设置页面,然后点击<code>Developer settings</code>选项进入开发者设置,然后字点击<code>Personal access tokens</code><br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/github_access_token.jpg" alt="alt"><br>点击右上角的<code>Generate new token</code>会让你输入密码确定,然后进入一个生成<code>token</code>的页面<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/generate_access_token.jpg" alt="alt"></p><p>输入<code>token</code>的描述,选择这个<code>token</code>权限,然后然后点击生成就可以了,然后复制保存下来,下次在进来就看不到了<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/generate_access_token_after.jpg" alt="alt"></p><p>左后还在 <code>Travis</code> 仓库配置界面<code>setting</code>里面 环境变量<code>Environment Variables</code>进行配置<code>token</code>方便在构建文件中引用:如下图<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/config_token.jpg" alt="alt"><br>4. 在博客的源码文件分支下添加<code>.travis,yml</code>配置文件,决定怎么执行构建任务,下面是<code>.travis,yml</code>的内容:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;jjeejj&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;wenjunjiang1993@163.com&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Update docs&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">&quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot;</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">global:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/jjeejj/jjeejj.github.io.git</span></span><br></pre></td></tr></table></figure><p>这其中的<code>config</code>改成对应你自己的</p><p>到此为止,就已经配置完成了,下面就让我们推送一篇文章测试一下的<br>现在我本地源码目录有新加的一篇文章:<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/new_article.jpg" alt="alt"></p><p>然后进行<code>push</code>提交(此刻应该等待编译成功了)</p><p>然后稍等一会就可以在博客网站上看到刚才的那篇文章了<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/new_article_show.jpg" alt="alt"></p><p>你也可以在<code>Travis</code>的博客仓库的控制台看到编译的日志<br><img src="/images/%E5%88%A9%E7%94%A8CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/new_article_build_log.jpg" alt="alt"></p><blockquote><p>这里备注一下,由于平常我们写文章都是使用<code>heox new draft</code>新建的草稿文件,是放在<code>_drafts</code>文件夹中的,写完之后需要手动<code>hexo publish</code>一下,移到<code>_psots</code>文件夹中的,使用构建时候,还是需要这样做的</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;每次写完一篇文章,都会手动执行&lt;code&gt;hexo g&lt;/code&gt;和&lt;code&gt;hexo d&lt;/code&gt;去生成静态网页后在进行部署到&lt;code&gt;Github page上去&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;而且为了保存文章的源码&lt;code&gt;md&lt;/code&gt;文件还需要&lt;code&gt;push&lt;/code&gt;到对应的仓库分支上,比较麻烦&lt;/p&gt;
&lt;p&gt;都说&lt;code&gt;懒惰&lt;/code&gt;推动着新的东西出现,那么能不能只保存原&lt;code&gt;md&lt;/code&gt;文件&lt;code&gt;push&lt;/code&gt;上去,其他的操作都让它自动去完成呢 ？&lt;/p&gt;
&lt;p&gt;答案肯定是可以的,下面就来讲解一下CI具体的实现方法(&lt;strong&gt;这里只讲解如何把travis接入&lt;/strong&gt;):&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://jjeejj.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的Object基础内部方法</title>
    <link href="https://jjeejj.github.io/2018/02/04/JavaScript%E4%B8%AD%E7%9A%84Object%E5%9F%BA%E7%A1%80%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://jjeejj.github.io/2018/02/04/JavaScript%E4%B8%AD%E7%9A%84Object%E5%9F%BA%E7%A1%80%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95/</id>
    <published>2018-02-04T14:22:23.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>对于<code>JavaScript</code>对象的操作基本上都会调用底层的对象内部方法,我们可以看出在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#table-5"><code>ES6</code></a>标准中定了<strong>14</strong>种内部方法.</p><p>双 <strong>[[]]</strong> 代表内部方法,在一般的<code>JS</code>代码中不可见,你可以调用、删除或覆写(<code>通过Proxy对象</code>)普通方法,但是无法操作内部方法.</p><hr><span id="more"></span><p>下面通过一个思维导图来展示这<strong>14</strong>种基础的内部方法</p><p><img src="/images/JavaScript%E4%B8%AD%E7%9A%84Object%E5%9F%BA%E7%A1%80%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95/Object%E5%9F%BA%E7%A1%80%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95.png" alt="Object"></p><blockquote><p>若看不清楚,可以在微信公众号后台发送 <strong>内部方法</strong> 获取高清图片</p></blockquote><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;对于&lt;code&gt;JavaScript&lt;/code&gt;对象的操作基本上都会调用底层的对象内部方法,我们可以看出在&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#table-5&quot;&gt;&lt;code&gt;ES6&lt;/code&gt;&lt;/a&gt;标准中定了&lt;strong&gt;14&lt;/strong&gt;种内部方法.&lt;/p&gt;
&lt;p&gt;双 &lt;strong&gt;[[]]&lt;/strong&gt; 代表内部方法,在一般的&lt;code&gt;JS&lt;/code&gt;代码中不可见,你可以调用、删除或覆写(&lt;code&gt;通过Proxy对象&lt;/code&gt;)普通方法,但是无法操作内部方法.&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="js" scheme="https://jjeejj.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>linux下各文件夹的作用</title>
    <link href="https://jjeejj.github.io/2018/01/28/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://jjeejj.github.io/2018/01/28/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2018-01-28T14:38:00.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>接触<code>linux</code>的新手看到<code>linux</code>有好多系统生成的文件夹,但是不知道每个文件夹有什么作用</p><p>下面来简单讲解一下<code>linux</code>下各文件夹的结构及用途介</p><hr><span id="more"></span><p><strong>讲解的环境是:阿里云的Ubuntu 16.04.3</strong></p><p>首先放一张根目录下的文件夹图<br><img src="/images/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/root_folder_show.jpg" alt="root_folder_show"></p><h5 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h5><p>该文件夹存放引导加载器(<code>bootstrap loader</code>)使用的文件,一般我们不会使用这里面的文件<br><img src="/images/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/boot_show.jpg" alt="root_folder_show"></p><h5 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h5><p>该文件夹存放的是设备文件即设备驱动程序,用户可以通过这些文件访问外部设备.<br><img src="/images/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/dev_show.jpg" alt="root_folder_show"></p><p><code>/dev/null</code>称为空设备,也称为位桶（bit bucket）或者黑洞(black hole),你可以向它输入任何数据，但任何写入它的数据都会被抛弃。通常用于处理不需要的输出流,<strong>这些操作通常由重定向完成</strong></p><p><code>/dev/shm/</code>这个目录是<code>linux</code>下一个利用内存虚拟出来的一个目录,这个目录中的文件都是保存在内存中，而不是磁盘上。其大小是非固定的，即不是预先分配好的内存来存储的。(<code>shm == shared memory</code>).<br>默认最大为内存的一半大小，使用<code>df -h</code>命令可以看到.但它并不会真正的占用这块内存，如果<code>/dev/shm/</code>下没有任何文件，它占用的内存实际上就是0字节<br>我们可以看到<code>/dev/shm</code>的文件系统为<code>tmpfs</code>，即为临时文件系统</p><p><img src="/images/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/df_h.jpg" alt="root_folder_show"></p><h5 id="home"><a href="#home" class="headerlink" title="home"></a>home</h5><p>该文件夹包含用户家目录，即系统上的所有实际数据存放的地方,你添加的用户 都会在该目录下创建一个和用户们相同的目录,为该用户的家目录</p><h5 id="root"><a href="#root" class="headerlink" title="root"></a>root</h5><p>超级管理员的家目录</p><h5 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h5><p><code>/bin</code>目录包含了引导启动所需的命令和普通用户可能用的命令.这些命令都是二进制文件的可执行程序(bin是binary的简称)，多是系统中重要的系统文件<br><img src="/images/linux%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8/bin_show.jpg" alt="root_folder_show"></p><h5 id="sbin"><a href="#sbin" class="headerlink" title="sbin"></a>sbin</h5><p><code>/sbin</code>目录类似<code>/bin</code> ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用</p><h5 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h5><p><code>/etc</code>目录存放着各种系统配置文件，其中包括了用户信息文件<code>/etc/passwd</code>， 系统初始化文件<code>/etc/rc</code>等。linux正是靠这些文件才得以正常地运行</p><h5 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h5><p><code>/lib</code>目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件,这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本,故可以使得可执行文件变得更小,节省空间.</p><h5 id="tmp"><a href="#tmp" class="headerlink" title="tmp"></a>tmp</h5><p>临时目录,对于某些程序来说,有些文件被用了一次两次之后,就不会再被用到,像这样的文件就放在这里.有些linux系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里</p><h5 id="opt"><a href="#opt" class="headerlink" title="opt"></a>opt</h5><p>这个目录主要存那些可选的程序.想尝试最新的<code>firefox</code>测试版吗？那就装到<code>/opt</code>目录下吧，这样，当你尝试完，想删掉<code>firefox</code>的时候,你就可以直接删除它，而不影响系统其他任何设置.安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面</p><p>举例:刚才装的测试版<code>firefox</code>,就可以装到<code>/opt/firefox_beta</code>目录下,<code>/opt/firefox_beta</code>目录下面就包含了运行<code>firefox</code>所需要的所有文件、库、数据等等.要删除<code>firefox</code>的时候，你只需删除<code>/opt/firefox_beta</code>目录即可，非常简单</p><h5 id="usr"><a href="#usr" class="headerlink" title="usr"></a>usr</h5><p><code>/usr</code>是个很重要的目录,因为所有程序安装在这里.</p><p><code>/usr/local</code>:本地安装的程序和其他东西，因为这样可以在升级新版系 统或新发行版时无须重新安装全部程序<br><code>/usr/bin</code>:集中了几乎所有用户命令，是系统的软件库.另有些命令在<code>/bin</code>或<code>/usr/local/bin</code>中<br><code>/usr/sbin</code>:包括了根文件系统不必要的系统管理命令<br><code>/usr/src</code>:linux内核的源代码</p><h5 id="var"><a href="#var" class="headerlink" title="var"></a>var</h5><p><code>/var</code>包含系统一般运行时要改变的数据,通常这些数据所在的目录的大小是要经常变化或扩充的</p><p><code>/var/lib</code>：存放系统正常运行时要改变的文件<br><code>/var/local</code>：存放<code>/usr/local</code>中安装的程序的可变数据<br><code>/var/log</code>:各种程序的日志(log)文件,这里的文件经常不确定地增长,应该定期清除。<br><code>/var/tmp</code>：比<code>/tmp</code>允许更大的或需要存在较长时间的临时文件</p><h5 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h5><p><code>/proc</code>文件系统是一个伪的文件系统,就是说它是一个实际上不存在的目录,因而这是一个非常特殊的目录.它并不存在于某个磁盘上,而是由核心在内存中产生.这个目录用于提供关于系统的信息</p><p><code>/proc/x</code>:关于进程<code>x</code>的信息目录,这<code>x</code>是这一进程的标识号.每个进程在 <code>/proc</code>下有一个名为自己进程号的目录<br><code>/proc/cpuinfo</code>:存放处理器(cpu)的信息，如cpu的类型、制造商、 型号和性能等<br><code>/proc/filesystems</code>:核心配置的文件系统信息<br><code>/proc/uptime</code>:系统启动的时间长度<br><code>/proc/version</code>:核心版本</p><h5 id="lost-found"><a href="#lost-found" class="headerlink" title="lost+found"></a>lost+found</h5><p>这个目录平时是空的,系统非正常关机而留下“无家可归”的文件就在这里</p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;接触&lt;code&gt;linux&lt;/code&gt;的新手看到&lt;code&gt;linux&lt;/code&gt;有好多系统生成的文件夹,但是不知道每个文件夹有什么作用&lt;/p&gt;
&lt;p&gt;下面来简单讲解一下&lt;code&gt;linux&lt;/code&gt;下各文件夹的结构及用途介&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内穿穿透工具lanproxy的配置使用</title>
    <link href="https://jjeejj.github.io/2018/01/21/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
    <id>https://jjeejj.github.io/2018/01/21/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</id>
    <published>2018-01-21T12:56:19.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>做微信开发或者把内网服务穿透出去,都会需要一个公网的地址。</p><p>经常使用的内网穿透工具有:<strong>花生壳</strong>,<strong>ngrok</strong>,<strong>魔法隧道</strong>等,但是这些域名都是第三方随机的，自定义域名的都是收费。</p><p>本来在<strong>window</strong>是使用的<strong>n2n</strong>内网穿透服务的,但是换了<code>Mac</code>之后没有找到<code>Mac</code>端的客户端。</p><p>所以本文讲解一下怎么用<strong>lanproxy</strong>搭建一个内网穿透的服务</p><hr><span id="more"></span><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><ul><li>一台公网的服务器(本文使用的是<code>Ubuntu 16.04.3 LTS</code>),运行<strong>lanproxy</strong>服务端</li><li>服务器<code>JDK</code>的环境(本文使用的<code>openjdk 1.8.0_151</code>)</li><li>客户端机器,运行<strong>lanproxy</strong>客户端,也需要<code>java</code>的环境需要安装<code>jdk</code>和<code>maven</code></li></ul><h4 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h4><h5 id="获取-lanproxy-的源码-并编译"><a href="#获取-lanproxy-的源码-并编译" class="headerlink" title="获取 lanproxy 的源码 并编译"></a>获取 lanproxy 的源码 并编译</h5><ol><li>去<a href="https://github.com/ffay/lanproxy"><code>lanproxy</code></a>的<code>github</code>地址去获取源码到本地<br> <code>git clone git@github.com:ffay/lanproxy.git</code></li><li>进入项目目录下 执行<code>mvn package</code>进行大包编译，打包编译的文件在<code>distribution</code>目录下,包括<code>client</code>和<code>server</code><br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/mvn_package.jpg"></li></ol><h5 id="配置并启动"><a href="#配置并启动" class="headerlink" title="配置并启动"></a>配置并启动</h5><h6 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h6><p>在<code>proxy-server-0.1</code>文件夹小的<code>conf</code>是<code>server</code>端的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server.bind=0.0.0.0 # 服务地址 </span><br><span class="line">server.port=4900 # 服务端口</span><br><span class="line"></span><br><span class="line"># ssl 配置可以默认</span><br><span class="line">server.ssl.enable=true</span><br><span class="line">server.ssl.bind=0.0.0.0</span><br><span class="line">server.ssl.port=4993</span><br><span class="line">server.ssl.jksPath=test.jks</span><br><span class="line">server.ssl.keyStorePassword=123456</span><br><span class="line">server.ssl.keyManagerPassword=123456</span><br><span class="line">server.ssl.needsClientAuth=false</span><br><span class="line"></span><br><span class="line">config.server.bind=0.0.0.0 # 服务页面管理访问地址</span><br><span class="line">config.server.port=8090 # 服务页面管理访问端口</span><br><span class="line">config.admin.username=admin # 服务页面管理访问用户名</span><br><span class="line">config.admin.password=admin # 服务页面管理访问用密码</span><br></pre></td></tr></table></figure><p>配置完成之后可以上该文件加到传服务器上,执行下面的命令<br><code>scp -r proxy-server-0.1 user@premote_ip:remote_dolder</code></p><p>在服务端执行<code>proxy-server-0.1/bin</code>文件夹下的<code>startuo.sh</code>，服务端启动</p><p>在浏览器上访问上面的你的 服务器<code>ip + prot</code>就可以看到管理页面了<br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/server_admin_login.jpg"></p><p>输入上面你配置的用户名密码登录进去，进去配置<br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/server_admin_login_success.jpg"></p><p>首先添加一个客户端:<br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/server_admin_add.jpg"></p><p>添加成功后在客户端管理那可以看到刚刚添加的客户端:<br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/server_admin_add_show.jpg"></p><p>然后在对刚刚添加成功的客户端进行配置:<br><img src="/images/%E5%86%85%E7%A9%BF%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7lanproxy%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/server_admin_add_config.jpg"></p><p>代理名称随便输入,一般都用本地代理服务的名称方便产看</p><blockquote><p>一个客户端代理可以配置多个本地服务端口</p></blockquote><h6 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h6><p>在<code>proxy-client-0.1</code>文件夹小的<code>conf</code>是<code>clent</code>端的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client.key=caaab8dc002c4e0f8b31ecb683d8900f # 这个key就是服务端中客户端管理的客户端秘钥</span><br><span class="line">ssl.enable=false</span><br><span class="line">ssl.jksPath=test.jks</span><br><span class="line">ssl.keyStorePassword=123456</span><br><span class="line"></span><br><span class="line">server.host= # 这个添加服务端地址,可以是配置的域名也可以是公网Ip</span><br><span class="line"></span><br><span class="line">#default ssl port is 4993</span><br><span class="line">server.port=4900 # 服务端端口</span><br></pre></td></tr></table></figure><p>这个客户端 是<code>java</code>版本的所以需要<code>jdk</code>环境，配置完成后在<code>window</code>执行<code>bin目录下的 startup.bat</code>,在<code>linux（mac</code>）环境中运行bin目录下的 <code>startup.sh</code></p><h4 id="nginx-的配置"><a href="#nginx-的配置" class="headerlink" title="nginx 的配置"></a>nginx 的配置</h4><p>如果你微信开发只能<code>80</code>端口，但是你只有一个<code>80</code>端口，而且有很多其他的服务,这个就需要配置<code>nginx</code>进行端口转发</p><p>首先你要有一个域名，配置一条<code>A</code>记录指向的服务比如这个代理服务你可以配置:<br><code>*.proxy.yourdomain</code> —- &gt; <code>你的公网ip地址</code></p><p>在<code>nginx</code>上进行配置，主要是根据 <code>server_name</code>进行转发</p><p>假如你本地的微信服务是<code>8080</code>端口，上面客户端配置添加的公网端口是<code>5000</code>那你可以这样配置，把你本地微信的服务穿透出去为：<br><code>wechat.proxy.yourdomain</code>(上面添加的域名<code>A</code>记录和这个有关系的，不然解析不到对应的服务器地址)那么<code>nginx</code>的配置为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name wechat.proxy.yourdomain;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass  http://127.0.0.1:5000/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后重启 <code>nginx -s reload</code> ,你就可以可以使用你配置<strong>代理域名服务</strong>访问你本地的服务了</p><p><strong>以后如果再有本地的服务需要穿透出去的,可以按照相同的方法进行配置</strong><br>如果在同一个机器上，就可以直接在服务配置页面下选择对应的客户端添加一个端口转发的配置就可以了<br>若不再一个机器上，就新建一个客户端在进行配置</p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;做微信开发或者把内网服务穿透出去,都会需要一个公网的地址。&lt;/p&gt;
&lt;p&gt;经常使用的内网穿透工具有:&lt;strong&gt;花生壳&lt;/strong&gt;,&lt;strong&gt;ngrok&lt;/strong&gt;,&lt;strong&gt;魔法隧道&lt;/strong&gt;等,但是这些域名都是第三方随机的，自定义域名的都是收费。&lt;/p&gt;
&lt;p&gt;本来在&lt;strong&gt;window&lt;/strong&gt;是使用的&lt;strong&gt;n2n&lt;/strong&gt;内网穿透服务的,但是换了&lt;code&gt;Mac&lt;/code&gt;之后没有找到&lt;code&gt;Mac&lt;/code&gt;端的客户端。&lt;/p&gt;
&lt;p&gt;所以本文讲解一下怎么用&lt;strong&gt;lanproxy&lt;/strong&gt;搭建一个内网穿透的服务&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="tools" scheme="https://jjeejj.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>homebrew的tap功能详解</title>
    <link href="https://jjeejj.github.io/2018/01/13/homebrew%E7%9A%84tap%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jjeejj.github.io/2018/01/13/homebrew%E7%9A%84tap%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/</id>
    <published>2018-01-13T15:14:55.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>Homebrew</code>是使用<code>ruby</code>开发的<code>Mac</code>的软件包管理器.<br>这里就说明一下有关<code>Taps(third-party-repositories)</code>的知识</p><hr><span id="more"></span><p><code>brew tap</code>可以为<code>brew</code>的软件的 跟踪,更新,安装添加更多的的<code>tap formulae</code></p><p>如果你在核心仓库没有找到你需要的软件,那么你就需要安装第三方的仓库去安装你需要的软件</p><p><code>tap</code>命令的仓库源默认来至于<code>Github</code>，但是这个命令也不限制于这一个地方</p><h4 id="brew-tap-命令"><a href="#brew-tap-命令" class="headerlink" title="brew tap 命令"></a>brew tap 命令</h4><ul><li><p><code>brew tap</code> 没有参数会自动更新已经存在的<code>tap</code>并列出当前已经<code>tapped</code>的仓库<br><img src="/images/homebrew%E7%9A%84tap%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/tap_update.jpg" alt="tap_update"><br><img src="/images/homebrew%E7%9A%84tap%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/tap_list.jpg" alt="tap_list"></p></li><li><p><code>brew tap &lt;user&gt;/&lt;repo&gt;</code> 在本地对这个 <code>https://github.com/user/repo</code> 仓库上做了一个浅度的克隆，完成之后 <code>brew</code>就可以在这个仓库包含的<code>formulae</code>上工作,好比就在<code>Homebrew</code>规范的仓库,你可使用<code>brew install</code> 或者<code>brew uninstall </code>安装或者卸载这个仓库上的软件。当你执行<code>brew update</code>这个命令时，<code>tap</code> 和 <code>formulae</code> 就会自定更新<br><img src="/images/homebrew%E7%9A%84tap%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/tap_one.jpg" alt="tap_one"></p></li><li><p><code>brew tap &lt;user&gt;/&lt;repo&gt; URL</code> 在本地对这个 <code>URL</code> 仓库上做了一个浅度的克隆,和上面一个参数命令是不一样的,<code>URL</code>没有默认关联到<code>Github</code>,这个<code>URL</code>没有要求必须是<code>HTTP</code>协议，任何位置和任何协议而且<strong>Git</strong>也是能很好的处理的</p></li><li><p><code>brew untap &lt;user&gt;/&lt;repo&gt; [&lt;user&gt;/&lt;repo&gt; &lt;user&gt;/&lt;repo&gt; ...]</code> 移除已经安装的<code>tap</code>.这个仓库被删除,<code>brew</code>就不在可用在这个仓库的<code>formulae</code>.可以同时删除几个仓库</p></li></ul><h4 id="仓库命名的规范"><a href="#仓库命名的规范" class="headerlink" title="仓库命名的规范"></a>仓库命名的规范</h4><ul><li>在 <code>Github</code>上,你的仓库名称必须是<code>homebrew-something</code>,为了使用一个参数的<code>brew tap</code>命令,<code>homebrew-</code>这个前缀不是可选的,是必须的。<br>  对于两个参数的<code>brew tap</code>命令没有这个限制,但是必须给出明确的全部的<code>URL</code>地址</li><li>当你在命令行使用<code>brew tap</code>时，你可以省略<code>homebrew-</code>这个前缀的</li></ul><p>也就是说:<code>brew tap username/foobar</code>是作为长版本<code>brew tap username/homebrew-foobar</code>使用的一个简写.</p><p><strong><code>brew</code>可以自己添加<code>homebrew-</code>前缀的在需要的时候</strong></p><h4 id="重复名称安装包的处理"><a href="#重复名称安装包的处理" class="headerlink" title="重复名称安装包的处理"></a>重复名称安装包的处理</h4><p>如果你想安装的一个安装包在你<code>tap</code>的一个仓库上,但是同时还出现在了<code>homebrew/core</code>上,这就意味着你必须明确指出<code>tap</code>的名称去安装它,否则就会默认安装<code>homebrew/core</code>上的包.</p><p>如果你想要是你安装的<code>tap</code>的优先顺序高于<code>homebrew/core</code>这个默认的仓库,你可以使用<code>brew tap-pin username/repo</code>去<strong>pin</strong>这个仓库.你可以使用<code>brew-tap-unpin username/repo</code> 恢复这个<code>pin</code></p><p>当你使用<code>brew install foo</code>这个命令时,<code>brew</code> 将按照下面的顺序去查找哪个<code>formula(tap)</code>将被使用:</p><ol><li>pinned taps</li><li>core formulae</li><li>other taps</li></ol><p>举个例子：</p><p>你想安装<code>vim</code>安装包,而且没有<code>pinned</code>某个仓库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install vim  # installs from homebrew/core</span><br><span class="line">brew install username/repo/vim  # installs from your custom repo</span><br></pre></td></tr></table></figure><p>你想安装<code>vim</code>安装包,而且有<code>pinned</code>的仓库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install vim  # installs from your custom repo</span><br><span class="line">brew install homebrew/core/vim # installs from homebrew/core</span><br></pre></td></tr></table></figure><h4 id="可以关注的Taps"><a href="#可以关注的Taps" class="headerlink" title="可以关注的Taps"></a>可以关注的Taps</h4><ul><li><a href="https://github.com/Homebrew/homebrew-php"><code>homebrew/php</code></a>:和<code>php</code>关联的<code>formulae</code></li><li><a href="https://github.com/denji/homebrew-nginx"><code>denji/nginx</code></a>: <code>nginx modules</code> 的<code>tap</code></li><li><a href="https://github.com/InstantClientTap/homebrew-instantclient"><code>InstantClientTap/instantclient</code></a>: <code>Oracle</code>客户端实例的<code>tap</code></li><li><a href="https://github.com/petere/homebrew-postgresql"><code>petere/postgresql</code></a>: 允许同时安装多个<code>PostgreSQL</code>版本的<code>tap</code></li><li><a href="https://github.com/dunn/homebrew-emacs"><code>dunn/emacs</code></a>: <code>Emacs package</code>的<code>tap</code></li><li><a href="https://github.com/sidaf/homebrew-pentest"><code>sidaf/pentest</code></a>: 渗透测试工具的<code>tap</code></li><li><a href="https://github.com/osrf/homebrew-simulation"><code>osrf/simulation</code></a>: 机器仿真的<code>tap</code></li></ul><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Homebrew&lt;/code&gt;是使用&lt;code&gt;ruby&lt;/code&gt;开发的&lt;code&gt;Mac&lt;/code&gt;的软件包管理器.&lt;br&gt;这里就说明一下有关&lt;code&gt;Taps(third-party-repositories)&lt;/code&gt;的知识&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="mac" scheme="https://jjeejj.github.io/tags/mac/"/>
    
    <category term="homebrew" scheme="https://jjeejj.github.io/tags/homebrew/"/>
    
  </entry>
  
  <entry>
    <title>mysql字段时间类型的比较</title>
    <link href="https://jjeejj.github.io/2018/01/06/mysql%E5%AD%97%E6%AE%B5%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://jjeejj.github.io/2018/01/06/mysql%E5%AD%97%E6%AE%B5%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2018-01-06T14:13:53.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>mysql</code>字段的时间类型分为5种:<code>DATE</code>,<code>DATETIME</code>,<code>TIME</code>,<code>TIMESTAMP</code>,<code>YEAR</code>;</p><p>下面就分别介绍这几种时间类型的区别</p><hr><span id="more"></span><table><thead><tr><th align="center">类型</th><th align="center">字节大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">零值</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3</td><td align="center">1000-01-01/<br/>9999-12-32</td><td align="center">YYYY-MM-DD</td><td align="center">0000-00-00</td><td align="center">日期值</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center">1000-01-01 00:00:00/<br>9999-12-32 23:59:59</td><td align="center">YYYY-MM-DD hh:mm:ss</td><td align="center">0000-00-00 00:00:00</td><td align="center">混合日期和时间值</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838:59:59/<br>838:59:59</td><td align="center">hh:mm:ss</td><td align="center">00:00:00</td><td align="center">时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">1970-01-01 00:00:01/<br>2038-01-19 03:14:07</td><td align="center">YYYY:MM:DD: hh:mm:ss</td><td align="center">0000-00-00 00:00:00</td><td align="center">混合日期和时间值,时间戳</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901/2155</td><td align="center">YYYY</td><td align="center">0000</td><td align="center">年份值</td></tr></tbody></table><p><strong>每个时间类型都有一个有效范围和一个零值,当指定的类型的值超过有效范围时,就会使用零值</strong></p><h4 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR"></a>YEAR</h4><p>该类型表示<strong>年</strong>,格式为<code>YYYY</code></p><p>有三种表示方法</p><ol><li>直接使用四位数字或字符串,范围是<strong>1901-2155</strong>,输入的格式为’YYYY’或YYYY,如输入‘2011’或2011就回直接保存为2011,若超过范围就会表示为0000</li><li>使用两位的字符串表示,如果插入为’00’-‘69’则表示为2000-2069,若插入’70-99’则表示为1970-1999.如输入’22’保存为2222，输入88保存为1988.’0’和’00’的效果一样</li><li>使用两位数字,如果插入为00-69则表示为2000-2069,若插入70-99则表示为1970-1999.如输入22保存为2222，输入88保存为1988.如果是0则表示为0000.注意该处和字符串的情况不一样</li></ol><h4 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h4><p>该类型表示<strong>时:分:秒</strong>,尽管时间范围为<strong>0～23</strong>,但是为了表示某些特殊的时间,<strong>mysql</strong>将小时的范围扩大了,并且支持负值。</p><p>对于<code>TIME</code>类型复制,标准的格式为<code>HH:MM:SS</code>,但不一定要这个格式</p><p>如果插入的格式为<code>D HH:MM:SS</code>则类似插入了<code>D*24+HH:MM:SS</code>,比如插入<code>2 23:12:12</code>,相当于<code>71:12:12</code></p><p>如果插入的格式为<code>HHMM</code>或则<code>SS</code>,那么其他位置就赋零值.比如<code>30</code> 相当于<code>00:00:30</code>，比如<code>11:30</code> 相当于<code>11:30:00</code></p><p>在<code>mysql</code>中，系统可以自动识别<code>HHMMSS</code>转化为标准格式.我们可以通过<code>CURRENT_TIME()</code>获取当前的<code>TIME</code>值</p><h4 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h4><p>该类型表示<strong>年-月-日</strong>,标准格式为<code>YYYY-MM-DD</code>,但是<code>mysql</code>中还支持一些不严谨的格式:比如<code>YYYY/MM/DD</code>等其他的符号来分割</p><p>在插入数据的数据的也可以使用<code>YY-MM-DD</code> 年份的转换和上面的<code>YEAR</code>类型的规则一样的</p><p>可以使用<code>CURRENT_DATE()</code> 函数获取当前的<code>DATE</code>值</p><h4 id="DATETIME"><a href="#DATETIME" class="headerlink" title="DATETIME"></a>DATETIME</h4><p>该类型表示<strong>YYYY-MM-DD hh:mm:ss</strong>,可以看出<code>DATE</code>和<code>TIME</code>类型的结合体.所以赋值的规则时和上面<code>DATE</code>和<code>TIME</code>的时一样的</p><h4 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h4><p>该类型表示为<strong>YYYY-MM DD hh:mm:ss</strong>,取值范围比<code>DATETIME</code>小,因此输入时一定要注意输入值的范围,超过范围会当作零值处理。<br>哈哈,到<code>2038</code>年后就别用这个类型了</p><blockquote><p>这只是一个简单的区分说明,具体<code>mysql</code>时间类型的说明 请参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-types.html">官方文档</a></p></blockquote><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt;字段的时间类型分为5种:&lt;code&gt;DATE&lt;/code&gt;,&lt;code&gt;DATETIME&lt;/code&gt;,&lt;code&gt;TIME&lt;/code&gt;,&lt;code&gt;TIMESTAMP&lt;/code&gt;,&lt;code&gt;YEAR&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;下面就分别介绍这几种时间类型的区别&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="https://jjeejj.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>为hexo博客添加RSS订阅功能</title>
    <link href="https://jjeejj.github.io/2017/12/30/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/"/>
    <id>https://jjeejj.github.io/2017/12/30/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/</id>
    <published>2017-12-30T10:49:07.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>RSS(Really Simple Syndication)</code> 简易信息聚合,在互联网上被广泛采用的内容包装和投递协.</p><p>是一种描述同步网站内容的格式,使用<code>xml</code>格式. 当网站内容更新时,可以通过订阅<code>RSS</code>源在<code>RSS</code>阅读器上获取更新的信息</p><p>大多数内容提供的网站都会提供<code>RSS</code>订阅的功能,方便用户去获取最新的内容.</p><p>本篇文章主要介绍怎么给自己的<code>hexo</code>博客添加<code>RSS</code>源 </p><hr><span id="more"></span><p>在<code>hexojs</code>用户下的仓库中发现两个<code>RSS</code>功能的<code>npm</code>包</p><ol><li><a href="https://github.com/hexojs/hexo-migrator-rss">hexo-migrator-rss</a></li><li><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></li></ol><p>不过第一个包是从 <code>RSS</code> 迁移所有文章到<code>source/_posts</code>文件夹中的,第二个才是生成<code>RSS</code>文件的包.</p><p>下面就介绍一下<strong>hexo-generator-feed</strong>的使用</p><h5 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h5><p>首选先安装这个包:<code>npm install hexo-generator-feed</code></p><p>然后在在<code>_config.yml</code>文件中配置该插件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">hub:</span></span><br><span class="line">    <span class="attr">content:</span></span><br><span class="line">    <span class="attr">content_limit:</span></span><br><span class="line">    <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>参数的含义：</p><ul><li><code>type</code>: <code>RSS</code>的类型(<code>atom/rss2</code>)</li><li><code>path</code>: 文件路径,默认是<code>atom.xml/rss2.xml</code></li><li><code>limit</code>: 展示文章的数量,使用<strong>0</strong>或则<strong>false</strong>代表展示全部</li><li><code>hub</code>: </li><li><code>content</code>: 在<code>RSS</code>文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code></li><li><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面<code>content</code>设置为<code>false</code>和<code>没有自定义的描述出现</code></li><li><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</li></ul><blockquote><p>此外还有一种方法,就是在<code>Next</code>主题的<code>_config.yml</code>文件中有个<code>rss</code>的配置，直接设置为<code>true</code>就可以了<br><img src="/images/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/next_rss.jpg" alt="alt"></p></blockquote><p>配置好之后运行<code>hexo g</code>就可以找到你博客的<code>pubilc</code> 文件夹下发现<code>atom.xml</code>文件了</p><p><img src="/images/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/atom_xml.jpg" alt="alt"></p><p>然后运行<code>hexo</code>服务就可以在个人站点处看到<code>RSS</code>的订阅图标了,点击这个图标就可以出现<code>RSS</code>订阅的地址,就可以添加到你的<code>RSS</code>阅读器方便查看博客的最新文章<br><img src="/images/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85%E5%8A%9F%E8%83%BD/rss_logo.jpg" alt="alt"></p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;RSS(Really Simple Syndication)&lt;/code&gt; 简易信息聚合,在互联网上被广泛采用的内容包装和投递协.&lt;/p&gt;
&lt;p&gt;是一种描述同步网站内容的格式,使用&lt;code&gt;xml&lt;/code&gt;格式. 当网站内容更新时,可以通过订阅&lt;code&gt;RSS&lt;/code&gt;源在&lt;code&gt;RSS&lt;/code&gt;阅读器上获取更新的信息&lt;/p&gt;
&lt;p&gt;大多数内容提供的网站都会提供&lt;code&gt;RSS&lt;/code&gt;订阅的功能,方便用户去获取最新的内容.&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍怎么给自己的&lt;code&gt;hexo&lt;/code&gt;博客添加&lt;code&gt;RSS&lt;/code&gt;源 &lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://jjeejj.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之ln</title>
    <link href="https://jjeejj.github.io/2017/12/24/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bln/"/>
    <id>https://jjeejj.github.io/2017/12/24/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bln/</id>
    <published>2017-12-24T20:43:42.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>linux</code>命令之 <strong>ln</strong></p><hr><p><code>ln</code>命令的功能是为某一个文件在另一个位置建立一个同步的链接.链接类型分为硬链接和符号链接(软链接),默认是硬链接,如果要创建符号链接就必须使用**-s**选项</p><p><strong>符号链接</strong>文件是一个独立的文件,但是它的许多属性依赖于源文件,所以给你符号链接文件设置权限是没有意义的</p><p>当我们在不同的目录用到相同的文件时,不需要在每一个目录放置一个文件,我们只需要在一个固定的目录放上该文件,然后在其他目录用<strong>ln</strong>命令创建链接就可以了</p><span id="more"></span><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>ln [选项] 参数</code></p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-s 创建符号链接(软链接)</li><li>-f,–force 强制建立文件或者目录的链接,不论文件或目录是否存在</li><li>-v,–verbose 显示命令的处理过程</li></ul><blockquote><p>常用的就这几个,具体的可以查看帮助 <code>ln --help</code>或者 <code>man ln</code></p></blockquote><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>源文件:指定链接的的源文件,如果使用**-s**创建软链接,则源文件可以是目录或文件;创建硬链接的时,则源文件参数只能是文件</li><li>目标文件:指定源文件链接的目标文件</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li><p>将在<code>/usr/python/bin/python3</code> 执行文件软链接到 <code>/usr/bin/python3</code>文件上</p><p><code>ln -s /usr/python/bin/python3 /usr/bin/python3</code></p><p> 使用该方法,可以在系统中安装多个<code>python</code>版本</p></li><li><p>将目录<code>/usr/mengqc/mub1</code>下的文件<code>m2.c</code>链接到目录<code>/usr/liu</code>下的文件<code>a2.c</code></p><p> <code>ln /usr/mengqc/mub1/m2.c /usr/liu/a2.c</code></p><p> 在执行<code>ln</code>命令之前，目录<code>/usr/liu</code>中不存在<code>a2.c</code>文件。执行<code>ln</code>之后，在<code>/usr/liu</code>目录中才有<code>a2.c</code>这一项，表明<code>m2.c</code>和<code>a2.c</code>链接起来（注意，<strong>二者在物理上是同一文件，指向硬盘的同一位置</strong>），利用<code>ls -l</code>命令可以看到链接数的变化</p></li><li><p>在目录<code>/usr/liu</code>下建立一个符号链接文件<code>abc</code>，使它指向目录<code>/usr/mengqc/mub1</code></p><p><code>ln -s /usr/mengqc/mub1 /usr/liu/abc</code></p><p>执行该命令后,<code>/usr/mengqc/mub1</code>代表的路径将存放在名为<code>/usr/liu/abc</code>的文件中</p></li></ol><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><ul><li><p>硬链接</p><p>  创建硬链接后，己经存在的文件的I节点号（Inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式(<code>ls -l</code>)的第二列中看到，无额外链接的文件的链接数为1</p><p>  在默认情况下，<code>ln</code>命令创建硬链接。<code>ln</code>命令会增加链接数，<code>rm</code>命令会减少链接数.一个文件除非链接数为0，否则不会从文件系统中被物理地删除</p><p>  限制:</p><pre><code>  1. 不能对目录做硬链接  2. 只有在同一个文件系统中才能创建</code></pre></li><li><p>软链接</p><p>  软链接，是将一个路径名链接到一个文件.这些文件是一种特别类型的文件。事实上，它只是一个文本文件,其中包含它提供链接的另一个文件的路径名,另一个文件是实际包含所有数据的文件.所有读、写文件内容的命令被用于符号链接时,将沿着链接方向前进来访问实际的文件</p><p>  <strong>与硬链接不同的是,软链接确实是一个新文件,当然它具有不同的I节点号;而硬链接并没有建立新文件</strong></p><p>  软链接没有硬链接的限制,可以对目录文件做符号链接,也可以在不同文件系统之间做软链接</p><p>  特点:</p><pre><code>  1. 删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据  2. 在目录长列表(`ls -l`)中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是`l`  3. 符号链接的大小是其链接文件的路径名中的字节数   </code></pre><p>  <img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bln/lns.png" alt="alt"></p></li></ul><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;linux&lt;/code&gt;命令之 &lt;strong&gt;ln&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;ln&lt;/code&gt;命令的功能是为某一个文件在另一个位置建立一个同步的链接.链接类型分为硬链接和符号链接(软链接),默认是硬链接,如果要创建符号链接就必须使用**-s**选项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号链接&lt;/strong&gt;文件是一个独立的文件,但是它的许多属性依赖于源文件,所以给你符号链接文件设置权限是没有意义的&lt;/p&gt;
&lt;p&gt;当我们在不同的目录用到相同的文件时,不需要在每一个目录放置一个文件,我们只需要在一个固定的目录放上该文件,然后在其他目录用&lt;strong&gt;ln&lt;/strong&gt;命令创建链接就可以了&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux系统配置免密码登录</title>
    <link href="https://jjeejj.github.io/2017/12/17/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>https://jjeejj.github.io/2017/12/17/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/</id>
    <published>2017-12-17T16:52:43.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>进行<code>linux</code>服务器管理的时候，经常需要登录进去，每个服务器都需要记住和输入对应的用户名和密码，是非常麻烦的。</p><p>所以这里配置一下服务器免密码进行登录，方便我们进行管理</p><hr><span id="more"></span><p>演示配置环境：客户端 <code>Mac</code>。服务器: <code>Ubuntu 16.04</code></p><p>首先放一张图,进行介绍密匙免密登录的原理</p><p><img src="/images/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/ssh-principle.jpg" alt="alt"></p><p>转化为图为：</p><p><img src="/images/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/ssh-principle-image.png" alt="alt"></p><h4 id="本地配置公钥-私钥"><a href="#本地配置公钥-私钥" class="headerlink" title="本地配置公钥/私钥"></a>本地配置公钥/私钥</h4><p>生产配置之前先检查自己之前是否配置过，如果之前配置过再重新生成，就会覆盖之前的记录，导致你之前配置的记录失效</p><p><strong>执行命令生成</strong><br><code>ssh-keygen -r rsa -C test@qq.com</code></p><p>执行该命令后会在用户根目录生产一个<code>.ssh</code>的文件夹<br><img src="/images/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/ssh-keygen.jpg" alt="alt"></p><p>创建的过程中会让你输入密码,可以不设置密码，一直回车就好</p><p>这里面<code>id_rsa</code>是私钥,<code>id_rsa.pub</code>是公钥，至于<code>konwn_hosts</code>文件是登录过服务器后自动生成的文件，用户保存远程服务器的指纹信息</p><blockquote><p>上面生产秘钥的命令中的 -r 参数是制定加密算法,-C 参数是制定 邮箱<br>对于window系统就需要安装<code>git</code>客户端 <a href="http://gitforwindows.org/"><code>msysgit</code></a></p></blockquote><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><p>需要把客户端生产的公钥<code>id_rsa.pub</code> 里面的内容拷贝到服务器上对应用户根目录下的<code>.ssh/authorized_keys</code>文件中。</p><p><strong>若没有该文件可以手动创建该文件</strong>。也可以在服务上进行生成公钥/私钥,执行的命令和上面第一步一样的</p><p>也可以直接使用<code>ssh-copy-id user@host</code>命令直接拷贝到远程服务器上,为了防止出错，建议使用该命令进行复制客户端的公钥</p><p>有时候可能会修改然<code>authorized_keys</code>文件的权限<br><code>chmod 600 authorized_keys</code></p><p>接下来看一下<code>ssh</code>的配置文件<code>/etc/ssh/sshd_config</code>中的配置项是否打开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile%h/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>确保上面这几项是打开的，非注释掉的</p><p>最后重启<code>ssh</code><br><code>service sshd restart</code></p><p>接下来就可以免密码登录的了,但是每次还是需要输入用户名和主机地址的，这可以在本地配置<code>alias</code>别名</p><p>如果你安装了<code>zsh</code>就在<code>.zshrc</code>文件中添加，如果没有安装就是默认的在<code>.bashrc</code> 文件中添加<br><code>alias ssh_name user@host</code></p><p>执行 <code>source .zshrc</code>  或 <code>source .bashrc</code> 生效配置文件</p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;进行&lt;code&gt;linux&lt;/code&gt;服务器管理的时候，经常需要登录进去，每个服务器都需要记住和输入对应的用户名和密码，是非常麻烦的。&lt;/p&gt;
&lt;p&gt;所以这里配置一下服务器免密码进行登录，方便我们进行管理&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之ls</title>
    <link href="https://jjeejj.github.io/2017/12/13/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/"/>
    <id>https://jjeejj.github.io/2017/12/13/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/</id>
    <published>2017-12-13T23:52:38.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>ls</code>命令用于显示工作目录下的内容，默认显示文件及子目录；带上参数后，我们可以用<code>ls</code>做更多的事</p><hr><span id="more"></span><h4 id="首先看看该命令的帮助"><a href="#首先看看该命令的帮助" class="headerlink" title="首先看看该命令的帮助"></a>首先看看该命令的帮助</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: ls [-ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1] [file ...]</span><br></pre></td></tr></table></figure><p>列出指定工作目录的的文件,默认是当前文件夹; 默认按照字母排序</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>ls [options] [files]</code></p><h4 id="选项-–-options"><a href="#选项-–-options" class="headerlink" title="选项 – options"></a>选项 – options</h4><ul><li>-a,–all 不忽略以 <strong>.</strong> 开头的文件,即隐藏文件，展示所有的文件</li><li>-A  同 -a ，但不列出 <strong>.</strong> (目前目录) 及 <strong>..</strong> (父目录)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-h,–human-readable 以人更易读的方式列出文件大小(e.g., 1K 234M 2G)</li><li>-r,–reverse 将文件以相反次序显示(默认依英文字母次序)</li><li>-R,–recursive  列出递归的目录即若目录下有文件，则以下之文件亦皆依序列出</li><li>-S 以文件的大小进行排序，从大到小排序</li><li>–block-size=SIZE 改变显示文件的基础单位大小</li><li>-d,–directory  只显示文件及名称，不显示内容</li><li>-t 通过修改时间进行排序，最新修改的在最上面</li><li>-p 在文件夹后面添加 <strong>/</strong> 标记</li></ul><h4 id="参数–files"><a href="#参数–files" class="headerlink" title="参数–files"></a>参数–files</h4><p>要展示的工作目录(默认是当前文件夹)</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>不带参数的<code>ls</code>命令，只列出文件及目录，没有其他附件信息</li></ol><p><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls.jpg" alt="alt"></p><blockquote><p>有时候你可能发现<code>ls</code>命令列出了其他信息,那是因为你的<code>ls</code>命令是带了参数<code>ls</code>命令的别名</p></blockquote><ol start="2"><li>以文件的大小进行排序</li></ol><p><code>ls -lhS</code><br><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls-S.jpg" alt="alt"></p><ol start="3"><li>指定显示文件大小的基本单位</li></ol><p>单位包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">K = Kilobyte</span><br><span class="line">M = Megabyte</span><br><span class="line">G = Gigabyte</span><br><span class="line">T = Terabyte</span><br><span class="line">P = Petabyte</span><br><span class="line">E = Exabyte</span><br><span class="line">Z = Zettabyte</span><br><span class="line">Y = Yottabyte</span><br></pre></td></tr></table></figure><p><code>ls -l --block-size=M</code><br><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls--blocksize.jpg" alt="alt"></p><blockquote><p>注意：使用强制基本单位后，不会显示小数，会四舍五入<br>如果在 <code>--block-size</code> 之前使用<code>-h</code>,<code>--block-size</code> 起作用；若在之后使用则<code>-h</code>起作用。谁在后谁起作用</p></blockquote><ol start="4"><li>只显示目录文件</li></ol><p><code>ls -ld */</code><br><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls-d.jpg" alt="alt"></p><ol start="5"><li>以时间进行排序，通过修改时间列出，最新修改的在最上面</li></ol><p><code>ls -lt</code><br><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls-t.jpg" alt="alt"></p><ol start="6"><li> 增加 / (斜线) 标记目录</li></ol><p><code>ls -lp</code><br><img src="/images/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bls/ls-p.jpg" alt="alt"></p><p><strong>详细的命令使用方式,可以使用<code>man ls</code> 或<code>ls --help</code> 查看</strong></p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt;命令用于显示工作目录下的内容，默认显示文件及子目录；带上参数后，我们可以用&lt;code&gt;ls&lt;/code&gt;做更多的事&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之scp</title>
    <link href="https://jjeejj.github.io/2017/12/02/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bscp/"/>
    <id>https://jjeejj.github.io/2017/12/02/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bscp/</id>
    <published>2017-12-02T14:31:31.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p>由于经常在<code>linux</code>服务器和本地进行文件传输,这样就需要了解文件传输的命令</p><hr><span id="more"></span><p>在没有文件传输工具的情况下,就必须了解有关的文件传输命令，下面就来说说这个命令<code>scp(secure copy)</code>,是<code>linux</code>系统下基于<code>ssh</code>登陆进行安全的远程文件拷贝命令</p><h4 id="首先看看该命令的帮助"><a href="#首先看看该命令的帮助" class="headerlink" title="首先看看该命令的帮助"></a>首先看看该命令的帮助</h4><p><code>scp</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>scp [可选参数] file_source file_target</code></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>-1: 强制scp命令使用ssh1协议</li><li>-2: 强制scp命令使用ssh12协议</li><li>-4: 强制scp命令只使用IPv4寻址</li><li>-6: 强制scp命令只使用IPv6寻址</li><li>-P: 指定数据传输用到的端口号</li><li>-v: 详细方式显示输出</li><li>-c cipher: 以cipher方式将数据进行传输加密,这个选项会直接传给ssh</li><li>-l: 限定用户所能使用的带宽，以Kbit/s为单位</li><li>-F: 指定一个替代的ssh配置文件，此参数直接传递给ssh</li><li>-p: 保留原文件的修改时间，访问时间和访问权限</li><li>-q: 不显示传输进度条</li><li>-r: 递归复制整个目录</li><li>-C: 允许压缩</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h5><p><strong>复制文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------</span><br><span class="line">一: </span><br><span class="line">scp loacl_file remote_username@remote_ip:remote_folder</span><br><span class="line">scp /home/space/music/1.mp4 root@www.test/com:/home/root/other/music</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">二:</span><br><span class="line">scp loacl_file remote_username@remote_ip:remote_file</span><br><span class="line">scp /home/space/music/1.mp4 root@www.test/com:/home/root/other/music/1.mp3</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">三:</span><br><span class="line">scp loacl_file remote_ip:remote_folder</span><br><span class="line">scp /home/space/music/1.mp4 www.test/com:/home/root/other/music</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">四:</span><br><span class="line">scp loacl_file remote_ip:remote_file</span><br><span class="line">scp /home/space/music/1.mp4 www.test/com:/home/root/other/music/1.mp3</span><br></pre></td></tr></table></figure><p>上面的例子中:</p><ul><li>前两个指定了用户名,执行命令后需要输入密码</li><li>后两个没有指定用户名,执行命令后需要输入用户名和密码</li><li>第一个和第三个只指定了目录，文件名称不变，对应本地的文件名称</li><li>第二个和第四个指定的文件名称</li></ul><blockquote><p>注意:复制文件时该命令不会创建文件夹，若服务器没有对应的文件夹，则会把文件夹名称当做文件的名称。对于上面第一个例子，若服务器上没有<code>music</code>文件夹，则会<code>music</code>当做文件名去对应<code>1.mp4</code><br>对于表达式中的<code>remote_ip</code>可以是<strong>ip</strong>地址或者对应映射的<strong>域名</strong></p></blockquote><p><strong>复制目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/space/music/ www.test.com:/home/root/others/  </span><br></pre></td></tr></table></figure><p>上面命令将本地 music 目录复制到远程 others 目录下</p><blockquote><p>复制目录是记得要加上<code>-r</code>参数.若服务器上没有指定的目录则会在服务器上自动创建一个目录</p></blockquote><h5 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h5><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@www.test.com:/home/root/others/ /home/space/music/ </span><br><span class="line">scp root@www.test/com:/home/root/other/music/1.mp3 /home/space/music/1.mp4 </span><br></pre></td></tr></table></figure><h5 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h5><ol><li>使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的</li><li>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号<br><code>scp -P 4500 /home/space/music/1.mp4 root@www.test/com:/home/root/other/music/1.mp3</code></li></ol><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;由于经常在&lt;code&gt;linux&lt;/code&gt;服务器和本地进行文件传输,这样就需要了解文件传输的命令&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Base64原理解析</title>
    <link href="https://jjeejj.github.io/2017/11/28/Base64%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://jjeejj.github.io/2017/11/28/Base64%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2017-11-28T21:40:10.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>Base64</strong>是基于64个字符进行转换的,因为2的6次方正好为64，所以<strong>6bit</strong>就可以表示出64个字符，因此在转换的过程中以<strong>6bit</strong>表示一个字符。</p><hr><span id="more"></span><p><strong>原理：</strong></p><p><strong>3x8=4x6</strong>,核心是这个公式</p><ol><li>base64的编码都是按字符串长度，以每3个8bit的字符为一组</li><li>针对每组，首先获取每个字符的ASCII编码值</li><li>将ASCII编码转换成8bit的二进制，得到一组3*8=24bit的字节</li><li>再将这24bit划分为4个6bit的字节，并在每个6bit的字节前面都填两个高位0，得到4个8bit的字节</li><li>将这4个8bit的字节转换成10进制，对照Base64编码表,得到对应编码后的字符</li></ol><p><strong>ASCII表</strong><br><img src="/images/Base64%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ascii_sheet.png" alt="alt"></p><p><strong>Base64编码表</strong><br><img src="/images/Base64%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/base64_sheet.png" alt="alt"></p><p><strong>案例</strong></p><ul><li>字符串长度能被3整除的:比如 wen</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         w           e          n</span><br><span class="line">ASCII:  119         101        110</span><br><span class="line">8bit:  01110111   01100101   01101110</span><br><span class="line">6bit:  011101  110110  010101  101110</span><br><span class="line">十进制:  29      54      21      46</span><br><span class="line">Base64:   d       2       V       u</span><br><span class="line"></span><br><span class="line">所以 &quot;wen&quot; ---- &gt; d2Vu</span><br></pre></td></tr></table></figure><ul><li>字符串长度不能被3整除时,比如：jiang</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         j          i           a          n           g</span><br><span class="line">ASCII:  106        105         97          110         103</span><br><span class="line">8bit:  01101010   01101001   01100001   01101110     01100111</span><br><span class="line">6bit:  011010  100110  100101  100001  011011 100110  011100  异常</span><br><span class="line">十进制:  26      38      37      33       27     38    28</span><br><span class="line">Base64:   a       m       l      h         b      m     c      =</span><br><span class="line"></span><br><span class="line">所以 &quot;jiang&quot; ---- &gt; amlhbmc=</span><br></pre></td></tr></table></figure><p>注意：<strong>Base64是四个字符为一组，不够的补=</strong></p><blockquote><p>工具网站：<br><a href="https://tool.lu/hexconvert/">进制转换</a><br><a href="http://tool.chinaz.com/Tools/Base64.aspx">Base64转换工具</a><br><a href="https://c.runoob.com/front-end/59">图片转base64</a></p></blockquote><p><strong>汉字转Base64</strong></p><p>这里需要注意，汉字本身可以有多种编码，比如<code>gb2312、utf-8、gbk</code>等等，每一种编码的<code>Base6</code>4对应值都不一样。下面的例子以<code>utf-8</code>为例</p><p><code>严</code>的<code>utf-8</code>为<code>E4B8A5</code>,写成二进制就是三字节的11100100 10111000 10100101,然后按照上面的规则转换得到<code>Base64</code> 编码为：5Lil</p><p>所以，汉字严（utf-8编码）的Base64值就是5Lil</p><p><em><strong>从上面英语字母或者汉字转换为Base64的来看，就是先转换为对应的编码的二进制，然后在进行转换</strong></em></p><p><strong>补充内容</strong></p><p>对于一张图片，我们进程看到这样的表达形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAA....</span><br></pre></td></tr></table></figure><p>这是<code>这是Data URI scheme</code>目的是将一些小数据，直接嵌入到网页中，而不用在引用外部</p><p>在上面<code>data</code>表示取得数据的协定名称,<code>image/png</code> 是数据类型名称,<code>base64</code> 是数据的编码方法,逗号后面就是这个image/png文件base64编码后的数据</p><p>Data URI scheme支持的类型有:</p><ul><li>data:,文本数据</li><li>data:text/plain,文本数据</li><li>data:text/html,HTML代码</li><li>data:text/html;base64,base64编码的HTML代码</li><li>data:text/css,CSS代码</li><li>data:text/css;base64,base64编码的CSS代码</li><li>data:text/javascript,Javascript代码</li><li>data:text/javascript;base64,base64编码的Javascript代码</li><li>data:image/gif;base64,base64编码的gif图片数据</li><li>data:image/png;base64,base64编码的png图片数据</li><li>data:image/jpeg;base64,base64编码的jpeg图片数据</li><li>data:image/x-icon;base64,base64编码的icon图片数据</li></ul><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Base64&lt;/strong&gt;是基于64个字符进行转换的,因为2的6次方正好为64，所以&lt;strong&gt;6bit&lt;/strong&gt;就可以表示出64个字符，因此在转换的过程中以&lt;strong&gt;6bit&lt;/strong&gt;表示一个字符。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="other" scheme="https://jjeejj.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>linux命令之at</title>
    <link href="https://jjeejj.github.io/2017/11/21/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bat/"/>
    <id>https://jjeejj.github.io/2017/11/21/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bat/</id>
    <published>2017-11-21T23:33:45.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>linux</code>命令之 <strong>at</strong></p><p><strong>at</strong> 在指定的时间执行一次特定的任务，即：一次性定时任务计划执行</p><hr><span id="more"></span><p>该命令是<code>atd</code>进程控制，首先查看一下该进程是否启动，一般是随着系统自动启动的<br><code>ps aux | grep atd</code></p><p>若没有启动，则需要手动进行启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/atd start</span><br><span class="line"></span><br><span class="line">支持的语法：Usage: /etc/init.d/atd &#123;start|stop|restart|force-reload|status&#125;</span><br></pre></td></tr></table></figure><p>若没有安装，则需要安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install at</span><br><span class="line">or</span><br><span class="line">yum install -y at</span><br></pre></td></tr></table></figure><h4 id="首先看看该命令的帮助"><a href="#首先看看该命令的帮助" class="headerlink" title="首先看看该命令的帮助"></a>首先看看该命令的帮助</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: at [-V] [-q x] [-f file] [-mMlbv] timespec ...</span><br><span class="line">       at [-V] [-q x] [-f file] [-mMlbv] -t time</span><br><span class="line">       at -c job ...</span><br><span class="line">       atq [-V] [-q x]</span><br><span class="line">       at [ -rd ] job ...</span><br><span class="line">       atrm [-V] job ...</span><br><span class="line">       batch</span><br></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>at (选项) (参数)</code></p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-f 指定包含具体指令的任务文件</li><li>-q 指定新任务的队列名称</li><li>-m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</li><li>-c 打印任务的内容到标准输出</li><li>-V 显示版本信息</li><li>-d 删除指定的待执行任务，还可以使用<strong>atrm</strong>删除</li><li>-l 显示待执行任务的列表，还可以使用<strong>atq</strong>显示</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>日期时间：指定任务执行的日期时间</p><h4 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h4><ul><li>当天的时间：hh:mm,加入时间已经过去，就放到明天执行</li><li>模糊的指定时间：<strong>midnight</strong>，<strong>noon</strong>,<strong>teatime</strong></li><li>采用十二进制的时间：在时间的后面<strong>am</strong>或者<strong>pm</strong></li><li>也可以指定执行命令的具体时间：<strong>month day</strong>(月 日),<strong>mm/dd/yy</strong>(月/日/年),<strong>dd.mm.tt</strong>(日/月/年),指定的日期必须跟在指定的时间后面</li><li>相对记时法：安排不就要执行的命令：<strong>time+count time-units</strong>，<strong>time</strong>就是指定的时间，<strong>time-units</strong>是单位有<strong>minutes</strong>,<strong>hours</strong>,<strong>days</strong>,<strong>weeks</strong>,<strong>count</strong>是时间数量：比如：<strong>at 5pm+3 days</strong></li><li>还有一种直接用<strong>today</strong>(今天),<strong>tomorrow</strong>(明天)来指定时间的，比如：<strong>at 5pm tomorrow</strong></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li><p>在当天17:35 输出时间到一个文件</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ at 17:36</span><br><span class="line">warning: commands will be executed using /bin/sh</span><br><span class="line">at&gt; date &gt; ./log.log</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 7 at Tue Nov 21 17:36:00 2017</span><br></pre></td></tr></table></figure></li><li><p>删除特定的任务</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># atq </span></span><br><span class="line">8 2013-01-06 17:20 a root </span><br><span class="line">7 2013-01-08 17:00 a root </span><br><span class="line">[root@localhost ~]<span class="comment"># atrm 7 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># atq </span></span><br><span class="line">8 2013-01-06 17:20 a root</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>输入完成之后按 <strong>ctrl+d</strong>保存退出</p></blockquote><h4 id="安全的问题"><a href="#安全的问题" class="headerlink" title="安全的问题"></a>安全的问题</h4><p>不是所有用户都可以运行<code>at</code>任务的。因为系统安全的原因。很多主机被攻击破解后，非常有可能运用一些计划任务来运行或搜集你的系统运行信息,并定时的发送给黑客。 所以，除非是你认可的帐号，否则先不要让他们使用 at 命令。</p><p>那怎么控制用户使用 at 命令的权限呢?</p><p>在这里面有两个文件进行控制的：</p><ul><li><code>/etc/at.allow</code>: 这个文件优先被寻找，若有这个文件，则写在这个文件的使用者才能使用，没有在这个文件用户不能使用的</li><li><code>/etc/at.deny</code>: 若没有<code>/etc/at.allow</code>这个文件，就会寻找<code>/etc/at.deny</code>这个文件，写在<code>at.deny</code>的用户是不可以使用的，没有在的就可以使用</li><li>若两个文件都没有，那么就只有<strong>root</strong>用户你可以使用这个命令</li></ul><blockquote><p>对于这个两个文件的书写时：<strong>一个帐号写一行</strong></p></blockquote><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;linux&lt;/code&gt;命令之 &lt;strong&gt;at&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;at&lt;/strong&gt; 在指定的时间执行一次特定的任务，即：一次性定时任务计划执行&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://jjeejj.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的VScode插件</title>
    <link href="https://jjeejj.github.io/2017/11/19/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84VScode%E6%8F%92%E4%BB%B6/"/>
    <id>https://jjeejj.github.io/2017/11/19/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84VScode%E6%8F%92%E4%BB%B6/</id>
    <published>2017-11-19T10:48:36.000Z</published>
    <updated>2021-06-08T10:43:22.149Z</updated>
    
    <content type="html"><![CDATA[<hr><p>有效的利用<code>VScode</code>插件能更方便我们的工作，提高我们的工作的效率</p><hr><span id="more"></span><h5 id="vscode-icons"><a href="#vscode-icons" class="headerlink" title="vscode-icons"></a>vscode-icons</h5><p>让你的左边栏的文件显示相应的<code>icon</code> 图表<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/vscode_icons.png" alt="alt"></p><h5 id="TODO-Parser"><a href="#TODO-Parser" class="headerlink" title="TODO Parser"></a>TODO Parser</h5><p>代办事项，会在左下角显示一个按钮，点击显示所有的代办事项<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/todo_parser.png" alt="alt"></p><h5 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open in browser"></a>open in browser</h5><p>右键选中文件，在浏览器中打开文件<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/open_in_browser.png" alt="alt"></p><h5 id="Git-History"><a href="#Git-History" class="headerlink" title="Git History"></a>Git History</h5><p>查看<code>Git</code>提交的历史，对比提交文件的差异。按 <code>F1</code><br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/git_history.png" alt="alt"></p><h5 id="Document-This"><a href="#Document-This" class="headerlink" title="Document This"></a>Document This</h5><p>自动生成<code>JSDoc</code>注释文档在<code>JS</code>或者<code>TS</code>文件中<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/document_this.png" alt="alt"></p><h5 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h5><p>格式化<code>JS</code>,<code>TS</code>,<code>CSS</code>文件</p><h5 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h5><p>很方便的部署构建<code>Docker</code>应用</p><h5 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h5><p>添加书签，很方便跳转过去。可以对书签进行管理<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/bookmarks.png" alt="alt"></p><h5 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName"></a>AutoFileName</h5><p>引用的时候自动补全文件的名称</p><h5 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h5><p>自动感应引入文件的路径</p><h5 id="Import-Cost"><a href="#Import-Cost" class="headerlink" title="Import Cost"></a>Import Cost</h5><p>显示引入包的大小<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/import_cost.png" alt="alt"></p><h5 id="vscode-wechat"><a href="#vscode-wechat" class="headerlink" title="vscode-wechat"></a>vscode-wechat</h5><p>微信小程序的插件，可以预览小程序</p><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p><code>Python</code>语言的插件</p><h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><p><code>Go</code>语言的插件</p><h5 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h5><p>支持执行定义在<code>package.json</code>文件中的脚本，验证定义的依赖模块<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/npm.png" alt="alt"></p><h5 id="npm-Intellnsense"><a href="#npm-Intellnsense" class="headerlink" title="npm Intellnsense"></a>npm Intellnsense</h5><p>能自动导入已经安装的<code>npm</code>包<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/npm_intellnsense.png" alt="alt"><br>选中之后出现已经安装的包<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/npm_intellnsense_show.png" alt="alt"></p><h5 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h5><p>选中代码去执行<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/runner_code_select.png" alt="alt"></p><p>还可以选中规定的的语言去执行<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/runner_code_language.png" alt="alt"><br>选中之后出现语言的列表<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/runner_code_language_select.png" alt="alt"></p><h5 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h5><p>启动一个开发者本地静态资源的服务<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/go_live.png" alt="alt"><br>点击启动之后：<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/go_live_running.png" alt="alt"></p><h5 id="solidity"><a href="#solidity" class="headerlink" title="solidity"></a>solidity</h5><p>以太坊开发语言<code>solidity</code>语言的支持</p><h5 id="emmet"><a href="#emmet" class="headerlink" title="emmet"></a>emmet</h5><p>这个插件从<code>sublime</code>到<code>Vscode</code>再到<code>Atom</code>一直在用,<code>web</code>开发者的利器</p><h5 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h5><p>开发 <code>VUE</code> 项目的插件,可以对 <code>VUE</code> 代码进行语法高亮和语法提示等功能 </p><h5 id="minapp"><a href="#minapp" class="headerlink" title="minapp"></a>minapp</h5><p>微信小程序文件语法高亮,智能提示的功能</p><h5 id="Bracket-Pair-Colorizer"><a href="#Bracket-Pair-Colorizer" class="headerlink" title="Bracket Pair Colorizer"></a>Bracket Pair Colorizer</h5><p>用不同的颜色显示 <code>&#123;&#125;</code> 方便区分不同的代码块, 默认的时候 <code>&#123;&#125;</code> 是白色的</p><h5 id="REST-Client"><a href="#REST-Client" class="headerlink" title="REST Client"></a>REST Client</h5><p>直接用 <code>Vscode</code> 发送 <code>Http</code> 请求 和查看 响应的结果 (调试 <code>API</code>接口)</p><h5 id="GitHub-Pull-Requests"><a href="#GitHub-Pull-Requests" class="headerlink" title="GitHub Pull Requests"></a>GitHub Pull Requests</h5><p>把 <code>Gothub Pull Requests</code> 的操作集成到 <code>Vscode</code> 中,方便操作,安装成功需要在 <code>Vscode</code> 中认证 <code>Gothub</code> 账号</p><h5 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h5><p>在浏览器中调试你的 <code>JS</code> 代码</p><h5 id="vscode-fileheader"><a href="#vscode-fileheader" class="headerlink" title="vscode-fileheader"></a>vscode-fileheader</h5><p>给一个文件 在文件顶部添加一些文件注释，包括： <code>Auth</code> , <code>LastModifiedBy</code> 两个变量 , <code>tpl</code> 模版变量，可以修改 该模版，对应修改显示的内容<br><img src="/images/vscode%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/vscode-fileheader.jpeg" alt="alt"></p><h5 id="Java-Extension-Pack"><a href="#Java-Extension-Pack" class="headerlink" title="Java Extension Pack"></a>Java Extension Pack</h5><p><code>Java</code> 在 <code>VsCode</code> 上开发插件集合包括 <strong>Language Support for Java™ by Red Hat</strong>, <strong>Debugger for Java</strong>, <strong>Java Test Runner</strong>,<strong>Maven Project Explorer</strong></p><h5 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h5><p>增强 Vscode 的  <code>Git</code> 功能, 完全包含上面推荐的 <code>Git History</code> 插件. 该插件强烈推荐</p><h5 id="RemoteHub"><a href="#RemoteHub" class="headerlink" title="RemoteHub"></a>RemoteHub</h5><p>在本地看某个 <code>GitHub repository</code> 的代码时,你就不需要将代码 clone 下来了，你可以直接打开这个 <code>repository</code> 相关的工作区，所有文件、文件夹都是从 GitHub 按需下载下来</p><h5 id="Live-Share"><a href="#Live-Share" class="headerlink" title="Live Share"></a>Live Share</h5><p>你可以将你本地的工作区,直接分享给你的同伴,然后你的同伴就可以直接编辑你的代码，与你共享代码调试、集成终端等等，而无需安装任何环境</p><h5 id="Live-Share-Audio"><a href="#Live-Share-Audio" class="headerlink" title="Live Share Audio"></a>Live Share Audio</h5><p><code>Live Share</code>的增强插件,可以让 <code>Live Share</code> 语音通信</p><h5 id="Remote-Development"><a href="#Remote-Development" class="headerlink" title="Remote Development"></a>Remote Development</h5><p>远程开发套件,可以让你在<code>Vscode</code>中打开在<strong>远程机器</strong>上 <strong>容器</strong>或者 <strong>WSL</strong> 中的任意文件夹及文件，然后利用<code>Vscode</code> 强大的功能</p><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;有效的利用&lt;code&gt;VScode&lt;/code&gt;插件能更方便我们的工作，提高我们的工作的效率&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="vscode" scheme="https://jjeejj.github.io/tags/vscode/"/>
    
    <category term="plguin" scheme="https://jjeejj.github.io/tags/plguin/"/>
    
  </entry>
  
  <entry>
    <title>mac命令行用sublime,vscode,atom打开目录或文件的方法</title>
    <link href="https://jjeejj.github.io/2017/11/18/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%A8sublime-vscode-atom%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://jjeejj.github.io/2017/11/18/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%A8sublime-vscode-atom%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2017-11-18T14:26:22.000Z</published>
    <updated>2021-06-08T10:43:22.145Z</updated>
    
    <content type="html"><![CDATA[<hr><p><code>MAC</code>  在命令行直接利用 <strong>sublime</strong>,<strong>vscode</strong>,<strong>atom</strong>，直接打开文件或者目录，能很高的提高开发效率</p><hr><span id="more"></span><p>总体的思路就是配置<code>alias</code>别名，但是<code>atom</code>有些意外的情况发生</p><ol><li><p>第一步打开终端，进到对应的用户目录下，找到你的<code>shell</code>配置文件</p><p> <img src="/images/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/shell_show.png" alt="shell_show"></p></li><li><p>修改对应的<code>shell</code>配置文件，若你安装过<code>oh_my_zsh</code>,打开<code>.zshrc</code>文件，若你是默认没有修改过就开<code>.bash_profile</code>文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias chrome=&quot;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome&quot;</span><br><span class="line">#alias atom=&quot;/Applications/Atom.app/Contents/MacOS/Atom&quot;</span><br><span class="line">alias vscode=&quot;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&quot;</span><br></pre></td></tr></table></figure><p> <img src="/images/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/shell_add.png" alt="shell_add"></p><p> 添加图中对应的<code>alias</code>,图中应用程序路径是我自己的，你可以查看自己应用程序路径添加上</p></li><li><p>执行以下命令让你修改的配置文件生效<br> <code>source ./.zshrc</code> 或者 <code>source ./.bash_profile</code></p></li></ol><p>在上面可以看出有关<code>atom</code>的那个别名被注释掉了，这个因为用<code>atom</code>别名打开一个文件或者目录的时候，后台应用程序被挂起，命令行不退出输入模式。如果退出输入模式那么<code>atom</code>应用程序也会被关闭。所以用别名指向应用程序的路径对<code>atom</code>是不可以行的。</p><p>那么对于<code>atom</code>怎么处理呢？<br>答案就是：在<code>atom</code>应用程序中，有个<strong>Install Shell Commonds</strong>功能选项<br><img src="/images/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/install_shell_commonds.png" alt="install_shell_commonds"><br><img src="/images/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/install_shell_commonds_success.png" alt="install_shell_commonds_success"></p><p>点击之后在命令行就可以直接使用<code>atom</code>打开目录或者文件</p><hr><p><strong>最新的更新 2018-09-18</strong></p><p><code>vscode</code> 配置命令行的另一种简单的方法,利用 <code>vscode</code> 自身所带的命令</p><ol><li><p>首先 使用 快捷键 <code>commandOrcontrol + shift + p</code> 打开 <code>VScode</code> 的  命令输入框,输入 <code>Shell</code><br><img src="/images/mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/vscode_command_shell.png" alt="vscode_command_shell"></p></li><li><p>选择在 <code>PATH 安装 code 命令</code>，然后成功安装</p></li><li><p>最后就可以在命令行中使用 <code>code</code> 命令操作 <code>vscode</code> 的了</p></li></ol><p><img src="/images/Wechatcode.jpg" alt="alt"><br><strong>扫描关注，查看更多文章，提高编程能力</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;code&gt;MAC&lt;/code&gt;  在命令行直接利用 &lt;strong&gt;sublime&lt;/strong&gt;,&lt;strong&gt;vscode&lt;/strong&gt;,&lt;strong&gt;atom&lt;/strong&gt;，直接打开文件或者目录，能很高的提高开发效率&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    
    <category term="other" scheme="https://jjeejj.github.io/tags/other/"/>
    
  </entry>
  
</feed>
